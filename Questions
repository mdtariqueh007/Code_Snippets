Cost of String

int solve(const string& S) {
    vector<int> freq(26, 0);

    for (char c : S) {
        freq[c - 'a']++;
    }

    int total = 0;

    for (int i = 0; i < 26; ++i) {
        for (int j = i + 1; j < 26; ++j) {
            total += freq[i] * freq[j] * abs(i - j);
        }
    }

    return total;
}

Good Sets

int solve(const string& s) {
    vector<int> lc;
    for (int i = 0; i < s.size(); ++i) {
        if (islower(s[i])) {
            lc.push_back(i);
        }
    }

    int m = 0;
    int c = 0;
    int p = -1;
    for (int i : lc) {
        if (p == -1 || s.substr(p + 1, i - p).compare(s.substr(p + 1, i - p)) != 0) {
            c += 1;
        } else {
            c = 1;
        }
        m = max(m, c);
        p = i;
    }

    return m;
}


Good Pair

#include <iostream>
#include <vector>
using namespace std;
vector<bool> sieve(int max_val) {
    vector<bool> is_prime(max_val + 1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i * i <= max_val; ++i) {
        if (is_prime[i]) {
            for (int j = i * i; j <= max_val; j += i) {
                is_prime[j] = false;
            }
        }
    }
    return is_prime;
}

int main() {
    int N;
    cin >> N;

    vector<int> A(N);
    int max_val = 0;
    for (int i = 0; i < N; ++i) {
        cin >> A[i];
        if (A[i] > max_val) {
            max_val = A[i];
        }
    }

    vector<bool> is_prime = sieve(max_val);

    int prime_count = 0, composite_count = 0;
    for (int i = 0; i < N; ++i) {
        if (is_prime[A[i]]) {
            prime_count++;
        } else {
            composite_count++;
        }
    }

    int good_pairs = prime_count * composite_count;
    cout << good_pairs << endl;

    return 0;
}


Minimal Strings



#include <iostream>
#include <unordered_set>
#include <string>
using namespace std;
void generateSubstrings(const string &s, int len, unordered_set<string> &substrings) {
    for (int i = 0; i <= s.size() - len; ++i) {
        substrings.insert(s.substr(i, len));
    }
}

string findMinimalString(const string &s) {
    unordered_set<string> substrings;
    for (int len = 1; ; ++len) {
        substrings.clear();
        generateSubstrings(s, len, substrings);
        string candidate(len, 'a');
        while (true) {
            if (substrings.find(candidate) == substrings.end()) {
                return candidate;
            }
            int pos = len - 1;
            while (pos >= 0 && candidate[pos] == 'z') {
                candidate[pos] = 'a';
                --pos;
            }
            if (pos < 0) break;
            ++candidate[pos];
        }
    }
}

int main() {
    string S;
    cin >> S;
    cout << findMinimalString(S) << endl;
    return 0;
}





//////////////////////////////

Prime Tree
Number of Partition
Maximizing Profit
Palindrome Triplet

/////////////////////


////// Prime Tree //////////////


prime tree
prime tree
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>

using namespace std;

const int MOD = 1e9 + 7;
const int MAXN = 101; 

vector<int> primes;
vector<vector<int>> adj;
vector<vector<long long>> dp;
bool is_prime[MAXN];

void sieve() {
    fill(is_prime, is_prime + MAXN, true);
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i < MAXN; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            for (int j = 2 * i; j < MAXN; j += i) {
                is_prime[j] = false;
            }
        }
    }
}

void preprocess(int N) {
    sieve();
    adj.clear();
    adj.resize(N);
    dp.clear();
    dp.assign(N, vector<long long>(primes.size(), 1));    
}

void dfs(int node, int par = -1) {
    for (int ne : adj[node]) {
        if (ne == par) continue;
        dfs(ne, node);        
        
        for (int i = 0; i < (int)primes.size(); i++) {
            long long t = 0;
            for (int j = 0; j < (int)primes.size(); j++) {
                if (is_prime[primes[i] + primes[j]]) continue;
                t += dp[ne][j];
                t %= MOD;
            }
            dp[node][i] *= t;
            dp[node][i] %= MOD;
        }
    }
}

int solve(int N, vector<vector<int>> edges) {
    preprocess(N);
    
    if (N == 1) return primes.size();
    
    for (vector<int> edge : edges) {
        adj[edge[0]].push_back(edge[1]);
        adj[edge[1]].push_back(edge[0]);     
    }
    
    dfs(0);
    long long ans = 0;
    
    for (int i = 0; i < (int)primes.size(); i++) {
        ans += dp[0][i];
        ans %= MOD;
    }
    
    return ans;
}

int main() {
    int N;
    cin >> N;
    vector<vector<int>> edges(N-1, vector<int>(2));
    for (int i = 0; i < N-1; i++) {
        cin >> edges[i][0] >> edges[i][1];
        edges[i][0]--; 
        edges[i][1]--;
    }

    cout << solve(N, edges) << endl;
    return 0;
}

///////////////////////////

//////////// NUmber of Partitions ////////////////////

def solve(N, ar):
    def gs(ar):
        return sum(ar)

    k = 0
    n = N
    ts = gs(ar)
    ps = [0] * n
    lc, rc = {}, {}

    ps[0] = ar[0]
    for i in range(1, n):
        ps[i] = ps[i - 1] + ar[i]

    for i in range(n - 1):
        rc[ps[i]] = rc.get(ps[i], 0) + 1

    mp = 0

    for i in range(n - 1):
        if 2 * ps[i] == ts:
            mp += 1

    for i in range(n):
        cu = ar[i]
        di = k - cu

        if i > 0:
            rc[ps[i - 1]] -= 1

        for j in range(n - 1):
            ls = ps[j]
            rs = ts - ls

            if 2 * ls + di == ts:
                mp += 1

        if i > 0:
            rc[ps[i - 1]] += 1

    return mp

T = int(input())

for _ in range(T):
    N = int(input())
    ar = list(map(int, input().split()))
    out_ = solve(N, ar)
    print(out_)
//////////////////////////////////////

/////////////////////Palindrome Triplet///////////////////

def pc(S):
    n = len(S)
    ip = [[False] * n for _ in range(n)]
    for i in range(n):
        ip[i][i] = True
    for ln in range(2, n + 1):
        for i in range(n - ln + 1):
            j = i + ln - 1
            if S[i] == S[j]:
                if ln == 2:
                    ip[i][j] = True
                else:
                    ip[i][j] = ip[i + 1][j - 1]
    return ip

def solve(n, S):
    ip = pc(S)
    
    dl = [0] * n
    for i in range(n):
        for j in range(i + 1):
            if ip[j][i]:
                dl[i] += 1
        if i > 0:
            dl[i] += dl[i - 1]
    
    dr = [0] * n
    for i in range(n - 1, -1, -1):
        for j in range(i, n):
            if ip[i][j]:
                dr[i] += 1
        if i < n - 1:
            dr[i] += dr[i + 1]
    
    gt = 0
    for i in range(1, n - 1):
        for j in range(i, n - 1):
            if ip[i][j]:
                gt += dl[i - 1] * dr[j + 1]
    
    return gt

T = int(input())
for _ in range(T):
    n = int(input())
    S = input()
    out_ = solve(n, S)
    print(out_)
//////////////////////////////////////

///// Prime Tree /////////////


def s(n, pr):
    prime = [True] * (n + 1)
    for p in range(2, int(n ** 0.5) + 1):
        if prime[p]:
            for i in range(p * p, n + 1, p):
                prime[i] = False
    for i in range(2, n + 1):
        if prime[i]:
            pr.append(i)

def t(n, pr):
    return n in pr

def coder(s, p, mod, a, dp, pr):
    for i in range(25):
        dp[s][i] = 1
    for u in a[s]:
        if u != p:
            coder(u, s, mod, a, dp, pr)
            for i in range(25):
                pos = 0
                for j in range(25):
                    if not t(pr[i] + pr[j], pr):
                        pos = (pos + dp[u][j]) % mod
                dp[s][i] = (dp[s][i] * pos) % mod

def f(n, edges):
    mod = 1000000007
    pr = []
    s(200, pr)
    dp = [[0] * 25 for _ in range(n + 1)]
    a = [[] for _ in range(n + 1)]
    for i in range(n - 1):
        a[edges[i][0]].append(edges[i][1])
        a[edges[i][1]].append(edges[i][0])
    coder(1, -1, mod, a, dp, pr)
    ans = 0
    for i in range(25):
        ans = (ans + dp[1][i]) % mod
    return ans
///////////////////////////////////////


////////////////// Maximising Profit /////////////////////


#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

// Function to calculate the maximum sum of money
int maximizeProfit(vector<int> &C, vector<int> &D, int n) {
    int itemCount = C.size();
    vector<pair<int, int>> items(itemCount);
    
    // Combine costs and delivery prices into a vector of pairs
    for (int i = 0; i < itemCount; ++i) {
        items[i] = {C[i], D[i]};
    }
    
    // Sort items based on their total value (cost + delivery price)
    sort(items.begin(), items.end(), [](const pair<int, int> &a, const pair<int, int> &b) {
        return (a.first + a.second) > (b.first + b.second);
    });
    
    // Select the top n items
    vector<int> selectedDeliveryPrices;
    int totalCost = 0;
    
    for (int i = 0; i < n; ++i) {
        totalCost += items[i].first;
        selectedDeliveryPrices.push_back(items[i].second);
    }
    
    // Find the minimum delivery price among the selected items
    int minDeliveryPrice = *min_element(selectedDeliveryPrices.begin(), selectedDeliveryPrices.end());
    
    // Add the delivery prices to the total cost
    totalCost += n * minDeliveryPrice;
    
    return totalCost;
}

int main() {
    // Example input
    vector<int> C = {10, 20, 30, 40};
    vector<int> D = {5, 4, 3, 2};
    int n = 2;
    
    // Calculate the maximum profit
    int result = maximizeProfit(C, D, n);
    
    // Output the result
    cout << "Maximum profit: " << result << endl;
    
    return 0;
}



////////////////////////////////


/////////// Google OA 13th July ////////////////////////

Find Palindrome
Complex Subsequence
First Subsequence
Or Xor
String machine
Subtree XOR
Maximum length Subarray
Range Function

////////////////////////////////////////////////////////


/////// String Machine ///////////////////


String Machine Google ✅

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool ok(int x, string &s1, string &s2, int n, int m, vector<int> &P) {
    vector<pair<int, int>> t;
    for (int i = 0; i <= x; i++) {
        t.push_back({P[i], s2[P[i] - 1] - 'a'});
    }
    sort(t.begin(), t.end());

    int i = 0, j = 0;
    while (i < s1.size() && j < t.size()) {
        if (s1[i] - 'a' == t[j].second) {
            j++;
            i++;
        }
        else j++;
    }
    return i == t.size();
}

int solve(int N, string s1, int M, string s2, vector<int> P) {
    int l = 0, h = M - 1;
    int ans = -1;
    while (l <= h) {
        int mid = (l + h) / 2;
        if (ok(mid, s1, s2, N, M, P)) {
            ans = mid + 1;
            h = mid - 1;
        } else {
            l = mid + 1;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    int T;
    cin >> T;
    for (int t = 0; t < T; t++) {
        int N, M;
        string s1, s2;
        cin >> N >> s1 >> M >> s2;

        vector<int> P(M);
        for (int i = 0; i < M; i++) {
            cin >> P[i];
        }

        cout << solve(N, s1, M, s2, P) << endl;
    }

    return 0;
}

///////////////////////////////////////


